# 排序算法

1. 选择排序（index.js）

时间复杂度：`O(n^2)`

思路：遍历数组，依次找出最小值与当前项交换

2. 快速排序（index1.js）

时间复杂度： `O(nlogn)`

分治算法： divide and conquer， D&C —— 一种著名的递归式问题解决方法

思路：找出基准值和分区，比如基准值为 arr[0]，最后返回比 arr[0]小的元素组成的分区 + arr[0] + 比 arr[0]大的元素组成的分区

3. 冒泡排序（index2.js）

时间复杂度：`O(n^2)`

思路：两两比较相邻元素的大小，交换位置。双层循环，外层遍历整个数组，内层冒泡交换元素

4. 插入排序（index3.js）

假设前面 n-1 （n≥2）个数已经是排好序的， 现将第 n 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好序的。

思路：使用双层循环，因为数组第一个元素已经是排好序的，所以我们从第二个元素开始，依次遍历。
内层循环依次跟 i 前面已经排好的序列比较，如果 < 前面的元素，就插入到它们前面。

5. 希尔排序（index4.js）

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序。

6. 堆排序（index5.js）

堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

堆排序就是利用堆进行排序的算法。基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它与堆数组的末尾元素交换，此时末尾元素就是最大值。
然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如此反复执行，便能得到一个有序序列了。


堆的性质：可以利用完全二叉树的性质。 k(i)≥k(2i)  1 ≤ i ≤ (n/2)   n为二叉树的结点总数 ， i为结点编号

